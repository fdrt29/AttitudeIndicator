# Авиагоризонт

## Тестовое задание

С помощью WPF разработать UserControl, реализующий работу прибора "Авиагоризонт" с обратной индикацией по крену и
тангажу; У UserControl создать внешние пять DependencyProperty для управления по крену (Roll), тангажу (Pitch),
скольжению (Drift), передельному крену (ValidRoll), предельному тангажу (ValidPitch). Прибор визуально представляет из
себя:

1. шкалу тангажа*, перемещающуюся по оси Y на +- 90 единиц и соответствующую параметру Pitch;
2. силуэт самолета*, вращающийся вокруг своей оси на +- 90 градусов и соответствующий параметру Roll;
3. символ скольжения "шарик"* перемещающийся в диапазоне -1 до 1 единиц и соответствующий параметру Drift;

- \* внешний вид прибора можно взять с глобальной сети по запросу "авиагоризонт с обратной индикацией", не обязательно
  имитировать объемный эффект шара на шкале тангажа. При превышении заданного крена или тангажа, силуэт самолета
  начинать работать в проблесковом режиме с частотой 2.5Гц.

## Пояснениe

Вся реализация заключена в `code-behind` контрола. Применения паттерну `MVVM` не нашел, так как работы с данными в целом
нет.

Шкалы тангажа и крена **отрисовываются на `Canvas`** вручную из кода в связи с обилием мелких деталей, сложности формы.
При изменении размера окна шкалы перерисовываются. Так же перерисовывается шкала тангажа при изменении
соотв. `DependencyProperty`, т.к. ей необходимо сдвинуться вниз\вверх.

В связи с таким решением интерфейс подстраивается под размеры окна заторможенно, однако считаю это приемлемым, т.к. по
ТЗ и, вероятно, в целом подобному UI не требуется отзывчивость при изменении размера окна. Так же иначе не получалось
точно сопоставлять деления шкал с индикатором(силуэтом самолета). Например, изначально были попытки реализовать тангаж с
помощью ScrollViewer.

**Подключен пакет** `CalcBinding`.

Опыт работы с WPF мал, многое изучал по ходу выполнения задания, поэтому сильно сомневаюсь в оптимальности решения через
отрисовку на `Canvas`, т.к. теряется вся адаптивность WPF.
